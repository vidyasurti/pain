start = TEI.2  

TEI.2 = element TEI.2 {teiHeader, textElem} #the name of an element is "text" - put it as textElem so that the schema is valid
    #teiHeader = element teiHeader {text}
    teiHeader = element teiHeader{teiHeaderType, status, fileDesc, encodingDesc, profileDesc, revisionDesc} #teiheader element has attributes type, status, fileDesc, and elements fileDesc, encodingDesc, and profileDesc
        teiHeaderType = attribute type {text} 
        status = attribute status {text}
        fileDesc = element fileDesc {titleStmt, extent, publicationStmt, sourceDesc}
            titleStmt = element titleStmt {title+, author, editor, sponsor, principal, respStmt, funder}
                title = element title {mixed{titleType?, titlen?}}
                    titleType = attribute type {text}
                    titlen = attribute n {text}
                author = element author {mixed{authorn}}
                    authorn = attribute n {text}
                editor = element editor {mixed{editorRole, editorn}}
                    editorRole = attribute role {text}
                    editorn = attribute n {text}
                sponsor = element sponsor {text}
                principal = element principal {text}
                respStmt = element respStmt {resp, name+}
                    resp = element resp {text}
                    name = element name {text}
                funder = element funder {mixed{fundern}}
                    fundern = attribute n {text}
                
            
            extent = element extent {text}
            
            #publicationStmt = element publicationStmt {publisher, pubPlace, authority, availability}
            publicationStmt = element publicationStmt {text}
            
            #sourceDesc = element sourceDesc {defaultSourceDesc, biblStruct}
            sourceDesc = element sourceDesc {text}
            
        #encodingDesc = element encodingDesc {refsDecl+}
        encodingDesc = element encodingDesc {text}
        #profileDesc = element profileDesc {langUsage}
        profileDesc = element profileDesc {text}
        #revisionDesc = element revisionDesc {change+}
        revisionDesc = element revisionDesc {text}


textElem = element text {lang, body}#textElem (called text in the file) has one child element called body
    lang = attribute lang {text}
    body = element body{div1+} #each body element has div1 elements
        div1 = element div1 {type, org, sample, milestone*, (stage | sp | div2)+} #each div1 element has 3 attributes: type, org, sample; all of these attributes are required
        #the div1 element has chidlren milestone (optional), stage (optional), sp (optional), and div2 (optional)
        #UPDATE - make sure the children that are elements can appear in whichever order and is still optional
            type = attribute type {("episode" | "choral")} #type is an attribute that either has values "episode" or "choral"
            org = attribute org {"uniform"} #org is an attribute, can only see "uniform" value for now
            sample = attribute sample {"complete"} #sample is an attribute, can only see "complete" value in document for now
            milestone = element milestone{text}
            stage = element stage {text}
            sp = element sp {div1n?, speaker?, p+, text} #speaker has question mark because there are a couple of errors in the scaffolding provided
                div1n = attribute n {text}
                #sp element will have one "speaker" element and one or more p elements
                speaker = element speaker {text}
                p = element p {(text | painStart* | painEnd* | stage* | placeName*)*}
                #portion of schema for pain markup
                    painStart = element painStart {rec, recGen, recNorm, painType, recRel?, inf?, infGen?, infNorm?, infRel?, text}
                        rec = attribute rec {text} #the receiver of pain, the name of the character, UNFINISHED - add type of character for groupings (do it separately)
                        recGen = attribute recGen {("man" | "woman" | "mix")} #gender of the receiver of pain can be man, woman, or mixedGender if it is a group
                        recNorm = attribute recNorm {("yes" | "no")} #when a receiver of pain is not socially accepted in Greek society, this value is 0 and otherwise 1
                        painType = attribute painType {("em" | "phys" | "both")} #painType can be em for emotional or phys for physcial
                        recRel = attribute recRel {text} #relation of the recevier of pain to the inflictor, UNFINISHED - will specify IDs of common patterns after markup is finished
                        inf = attribute inf {text} #the inflictor of pain, the name of the character, UNFINISHED - add type of character for groupings (do it separately)
                        infGen = attribute infGen {("man" | "woman" | "mix")} #gender of the receiver of pain can be man, woman, or mixedGender if it is a group
                        infNorm = attribute infNorm {("yes" | "no")} #when an inflictor of pain is not socially accepted in Greek society, this value is 0 and otherwise 1
                        infRel = attribute infRel {text} #relation of the inflictor of pain to the receiver, UNFINISHED - will specify IDs of common patterns after markup is finished
                    painEnd = element painEnd {text}
                 #end of schema for pain markup
                    placeName = element placeName {key, authname, text}
                        key = attribute key {text}
                        authname = attribute authname {text}
            div2 = element div2 {div2Type, div2n?, div2Org, div2Sample, text, div2sp*, div2p*}
                div2Type = attribute type {text}
                div2n = attribute n {xsd:int}
                div2Org = attribute org {text}
                div2Sample = attribute sample {text}
                div2sp = element sp {div2speaker, div2p+}
                    div2speaker = element speaker {text}
                    div2p = element p {(text | painStart* | painEnd* | stage* | placeName*)*}